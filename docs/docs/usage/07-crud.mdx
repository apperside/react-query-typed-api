# CRUD ENDPOINTS

CRUD is an acronim for Create,Read,Update,Delete, which are the four major functions used to interact with data resources.
This library comes with some utility type to help you consuming RESTFul endpoints for CRUD operations very conventienly.
CRUD apis are all about conventions, and are usually implemented by following some patterns involving the endpoints structure and the [HTTP Verb](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) used to interact with the endpoint.

Given a resource (which can be a blog post, an ecommerce order, a user or anything), a RESTFul api for CRUD operations should at least allow us to:

- get all resources of a given type
- get one resource by its id
- create a new item
- update an item
- delete one item

Given for example a resource named `order`, and being `http://myawesomeserver.com/api/` the base api url, these operations can be defined by the following sample endpoints<br />

| HTTP VERB              | ENDPOINT                                  | DESCRIPTION                        |
| ---------------------- | ----------------------------------------- | ---------------------------------- |
| **GET**                | http://myawesomeserver.com/api/orders     | get all orders                     |
| **GET**                | http://myawesomeserver.com/api/orders/:id | get one orer by id                 |
| **POST**               | http://myawesomeserver.com/api/orders     | create a new order                 |
| **PUT**( or **PATCH**) | http://myawesomeserver.com/api/orders/:id | update the order with the given id |
| **DELETE**             | http://myawesomeserver.com/api/orders/:id | delete the order with the given id |

And so on for each resource you have to deal with. <br/><br/>
In addition to defining a pattern on how to interact with the resources, we also need to define a standard for the responses.<br/>
Once we have a predictable way to query the resources, and we have a predictable response structure, typescript gives us a lot of room to abstract this concepts.
This is where react-query-typed-api's rest type utilities comes into play.

What we need is, given a resource, generate all the routes and map them with their associated typings without needing to write all of them manually.
To do this, we will use once again [typescript's declaration merging feature](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).

The first thing you need to do is declaring all the resources you want to work with by extending the [RoutesModelMapping](/docs/api/interfaces/crud.RoutesModelMapping) interface

Here is an example of how you have to define this mapping.

```typescript
type MyType1 = { field1: string };
type MyType2 = { field2: number };

export interface RoutesModelMapping {
  my-resource1: MyType1;
  my-resource2: MyType2;
}
```

The second thing you need to to is to extend the [CustomCrudRoutes](/docs/api/interfaces/crud.CustomCrudRoutes) interface:

```typescript
export interface CustomCrudRoutes
  extends RoutesForModel<"my-resource1">,
    RoutesForModel<"my-resource2"> {}
```

This will generate the followind endpoints

```
http://myawesomeserver.com/api/my-resource1
http://myawesomeserver.com/api/my-resource1/:id
http://myawesomeserver.com/api/my-resource1
http://myawesomeserver.com/api/my-resource1/:id
http://myawesomeserver.com/api/my-resource1/:id

http://myawesomeserver.com/api/my-resource2
http://myawesomeserver.com/api/my-resource2/:id
http://myawesomeserver.com/api/my-resource2
http://myawesomeserver.com/api/my-resource2/:id
http://myawesomeserver.com/api/my-resource2/:id
```

